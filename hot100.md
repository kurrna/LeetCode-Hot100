- 二分查找(Binary Search)

  ```cpp
  int l = 0, r = nums.size() - 1;
  while (l <= r) {
  	int mid = (r - l) / 2 + l;
      if (nums[mid] < target) {
          l = mid + 1;
      } else (nums[mid] > target) {
          r = mid - 1;
      } else {
          // return true;
      }
  }
  return false;
  ```

  - 其中`int mid = (r - l) / 2 + l`一步向下取整，避免了数字比较大时向上溢出

- 归并排序（逆序对问题……）

  ```cpp
  class Sort {
      public:
      void Merge(vector<int> &arr, int l, int mid, int r) {
          int i = l, j = mid + 1, k = l;
          auto tmp = arr;
          while (i <= mid && j <= r) {
              if (arr[i] <= arr[j]) {
                  tmp[k++] = arr[i++];
              } else {
                  tmp[k++] = arr[j++];
              }
          }
          if (i > mid) {
              while (k <= r) tmp[k++] = arr[j++];
          } else {
              while (k <= r) tmp[k++] = arr[i++];
          }
          arr = tmp;
      }
      void MergeSort(vector<int> &arr, int l, int r) {
      	if (l < r) {
      		int mid = (r - l) / 2 + l;
      		MergeSort(arr, l, mid);
      		MergeSort(arr, mid + 1, r);
          	for (int i = l; i <= r; i++) {
  		  		//...
              }
      		Merge(arr, l, mid, r);
          }
      }
  };
  ```

  

- 动态规划：139. 单词拆分

  ```cpp
  class Solution {
  public:
      bool wordBreak(string s, vector<string> &wordDict) {
          auto wordDictSet = unordered_set<string>();
          for (auto word: wordDict) {
              wordDictSet.insert(word);
          }
          auto dp = vector<bool>(s.size() + 1);
          dp[0] = true;
          for (int i = 1; i <= s.size(); i++) {
              for (int j = 0; j < i; ++j) {
                  if (dp[j] && wordDictSet.find(s.substr(j, i - j)) != wordDictSet.end()) {
                      dp[i] = true;
                      break;
                  }
              }
          }
          return dp[s.size()];
      }
  };
  ```

  - dp存储s[i]前面是否可以用空格分隔
  
- 公式二维动态规划：72.最小编辑距离

  ```cpp
  class Solution {
      public:
      int minDistance(string word1, string word2) {
          if (word1.size() < word2.size()) swap(word1, word2);
          int m = word1.size(), n = word2.size();
          word1 = " " + word1, word2 = " " + word2;
          vector<int> dp(n + 1, 0);
          for (int j = 1; j <= n; j++) {
              dp[j] = j;
          }
          for (int i = 1; i <= m; i++) {
              // prev: dp[i-1][j-1]
              // temp: dp[i-1][j]
              // d[j-1]: dp[i][j-1]
              int prev = dp[0]; 
              dp[0] = i; // dp[i][0] = i;
              for (int j = 1; j <= n; j++) {
                  int temp = dp[j]; 
                  if (word1[i] == word2[j]) {
                      dp[j] = prev;
                  } else {
                      dp[j] = min({dp[j-1], prev, temp}) + 1;
                  }
                  prev = temp;
              }
          }
          return dp[n];
      }
  };
  ```

  - dp\[i]\[j]表示word1前i个和word2前j个的

- 最大回文串长度(manacher算法)

  ```cpp
  string longestPalindrome(string s) {
  	if (s.empty()) return "";
  	string t = "#";
  	for (char c : s) {
  		t += c;
  		t+= "#";
  	}
      int n = t.size(); // n为奇数
      vector<int> p(n, 0);
      int center = 0, right = 0;
      int max_len = 0, start = 0;
      for (int i = 0; i < n; i++) {
          int mirror = 2 * center - i;
          if (i < right) p[i] = min(right - i, p[mirror]);
          int a = i + p[i] + 1, b = i - p[i] - 1;
          while (a < n && b >= 0 && t[a] == t[b]) {
              ++p[i];
              ++a;
              --b;
          }
          if (i + p[i] > right) {
              right = i + p[i];
              center = i;
          }
          if (max_len < p[i]) {
              max_len = p[i];
              start = (i - max_len) / 2;
          }
      }
      return s.substr(start, max_len);
  }
  ```

- 两个正序数组的中位数(4)

  ```cpp
  double findMedianSortedArrays(vector<int> &nums1, vector<int> &nums2) {
      if (nums1.size() < nums2.size()) findMedianSOrtedArrays(nums2, nums1);
      int m = nums1.size(), n = nums2.size();
      int left = 0, right = m;
      // median1: 前一部分的最大值
      // median2: 后一部分的最小值
      int median1 = 0, median2 = 0;
      // 始终对较小的nums1进行二分搜索
      while (left <= right) {
          // i是nums1的下标，j是nums2的下标
          int i = (left + right) / 2;
          int j = (m + n + 1) / 2 - i;
          int num_im1 = i == 0 ? INT_MIN : nums1[i-1];
          int num_i = i == m ? INT_MAX : nums1[i];
          int num_jm1 = j == 0 ? INT_MIN : nums2[j-1];
          int num_j = j == n ? INT_MAX : nums2[j];
          if (num_im1 <= num_j) {
              median1 = max(num_im1, num_jm1);
              median2 = min(num_i, num_j);
              left = i + 1;
          } else {
              right = i - 1;
          }
          return (m + n) & 1 ? median1 : (median1 + median2) / 2.0;
      }
  }
  ```


- 并查集

  ```cpp
  class UnionFind {
      private:
      vector<int> parent;
      vector<int> rank;
      
      public:
      UnionFind(int n) {
          parent.resize(n);
          rank.resize(n, 0);
          // 初始化：每个元素的父节点是自身
          for (int i = 0; i < n; i++) {
              parent[i] = i;
          }
      }
      
      // 查找父节点并压缩路径
      int find(int x) {
          if (parent[x] != x) {
              parent[x] = find(parent[x]);
          }
          return parent[x];
      }
  
      // 按秩合并两个集合
      bool unite(int x, int y) {
          int rootX = find(x), rootY = find(y);
          if (rootX == rootY) return false;
          
          if (rank[rootX] > rank[rootY]) {
      		parent[rootY] = rootX;  // 秩大的作为根
  		} else if (rank[rootX] < rank[rootY]) {
      		parent[rootX] = rootY;  // 秩大的作为根
  		} else {
      		// 秩相等时，任意合并（这里选rootX作为新根）
      		parent[rootY] = rootX;
      		rank[rootX]++;  // 只有此时秩才会增加
  		}
          return true;
      }
  };
  
  // 判断无向图是否存在环
  bool hasCycle(const vector<pair<int, int>> &edges, int n) {
  	UnionFind(n);
      for (const auto &edge : edges) {
          int u = edge.first, v = edge.second;
          if (uf.find(u) == uf.find(v)) {
              return true;
          }
          uf.unite(u, v);
      }
      return false;
  }
  ```

  堆
  
  ```cpp
  class MaxHeap {
      public:
      MaxHeap() = default;
      
      void push(int val) {
          data.push_back(val);
          siftUp(data.size() - 1);
      }
      
      void pop() {
          if (data.empty()) return;
          data[0] = data.back();
          data.pop_back();
          if (!data.empty()) siftDown(0);
      }
      
      int top() {
          if (data.empty()) return -1;
          return data[0];
      }
      
      bool empty() {return data.empty();}
      private:
      vector<int> data;
      
      void siftUp(size_t idx) {
          while (idx > 0) {
              size_t parent = (idx - 1) / 2;
              if (data[parent] >= data[idx]) break;
              swap(data[parent], data[idx]);
              idx = parent;
          }
      }
      
      void siftDown(size_t idx) {
          size_t n = data.size();
          while (true) {
              size_t left = idx * 2 + 1;
              size_t right = idx * 2 + 2;
              size_t largest = idx;
              // 与孩子节点中较大的进行交换
              if (left < n && data[left] > data[largest]) 
                  largest = left;
              if (right < n && data[right] > data[largest])
                  largest = right;
              swap(data[idx], data[largest]);
              idx = largest;
          }
      }
  }
  ```
  
  